{"ast":null,"code":"import { a as _createClass, b as _classCallCheck } from '../_rollupPluginBabelHelpers-3c58f0e3.js';\nimport { isString } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport IMask from '../core/holder.js';\n/** Supported mask type */\n\n/** Provides common masking stuff */\n\nvar Masked = /*#__PURE__*/function () {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n  function Masked(opts) {\n    _classCallCheck(this, Masked);\n\n    this._value = '';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, {}, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  _createClass(Masked, [{\n    key: \"updateOptions\",\n    value: function updateOptions(opts) {\n      if (!Object.keys(opts).length) return;\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n    /**\r\n      Sets new options\r\n      @protected\r\n    */\n\n  }, {\n    key: \"_update\",\n    value: function _update(opts) {\n      Object.assign(this, opts);\n    }\n    /** Mask state */\n\n  }, {\n    key: \"reset\",\n\n    /** Resets value */\n    value: function reset() {\n      this._value = '';\n    }\n    /** */\n\n  }, {\n    key: \"resolve\",\n\n    /** Resolve new value */\n    value: function resolve(value) {\n      this.reset();\n      this.append(value, {\n        input: true\n      }, '');\n      this.doCommit();\n      return this.value;\n    }\n    /** */\n\n  }, {\n    key: \"nearestInputPos\",\n\n    /** Finds nearest input position in direction */\n    value: function nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n    /** Extracts value in range considering flags */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return this.value.slice(fromPos, toPos);\n    }\n    /** Extracts tail in range */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n    }\n    /** Appends tail */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n      return tail.appendTo(this);\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      ch = this.doPrepare(ch, flags);\n      if (!ch) return new ChangeDetails();\n      this._value += ch;\n      return new ChangeDetails({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendChar\",\n    value: function _appendChar(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var checkTail = arguments.length > 2 ? arguments[2] : undefined;\n      var consistentState = this.state;\n\n      var details = this._appendCharRaw(ch, flags);\n\n      if (details.inserted) {\n        var consistentTail;\n        var appended = this.doValidate(flags) !== false;\n\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          var beforeTailState = this.state;\n\n          if (this.overwrite) {\n            consistentTail = checkTail.state;\n            checkTail.shiftBefore(this.value.length);\n          }\n\n          var tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString(); // if ok, rollback state after tail\n\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        } // revert all if something went wrong\n\n\n        if (!appended) {\n          details = new ChangeDetails();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n\n      return details;\n    }\n    /** Appends optional placeholder at end */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      return new ChangeDetails();\n    }\n    /** Appends symbols considering flags */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"append\",\n    value: function append(str, flags, tail) {\n      if (!isString(str)) throw new Error('value should be string');\n      var details = new ChangeDetails();\n      var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n      if (flags.tail) flags._beforeTailState = this.state;\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        details.aggregate(this._appendChar(str[ci], flags, checkTail));\n      } // append tail but aggregate only tailShift\n\n\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n\n      return details;\n    }\n    /** */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n      return new ChangeDetails();\n    }\n    /** Calls function and reapplies current value */\n\n  }, {\n    key: \"withValueRefresh\",\n    value: function withValueRefresh(fn) {\n      if (this._refreshing || !this.isInitialized) return fn();\n      this._refreshing = true;\n      var rawInput = this.rawInputValue;\n      var value = this.value;\n      var ret = fn();\n      this.rawInputValue = rawInput; // append lost trailing chars at end\n\n      if (this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.value.length), {}, '');\n      }\n\n      delete this._refreshing;\n      return ret;\n    }\n    /** */\n\n  }, {\n    key: \"runIsolated\",\n    value: function runIsolated(fn) {\n      if (this._isolated || !this.isInitialized) return fn(this);\n      this._isolated = true;\n      var state = this.state;\n      var ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n    /**\r\n      Prepares string before mask processing\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doPrepare\",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.prepare ? this.prepare(str, this, flags) : str;\n    }\n    /**\r\n      Validates if value is acceptable\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doValidate\",\n    value: function doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n    /**\r\n      Does additional processing in the end of editing\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n    /** */\n\n  }, {\n    key: \"doFormat\",\n    value: function doFormat(value) {\n      return this.format ? this.format(value, this) : value;\n    }\n    /** */\n\n  }, {\n    key: \"doParse\",\n    value: function doParse(str) {\n      return this.parse ? this.parse(str, this) : str;\n    }\n    /** */\n\n  }, {\n    key: \"splice\",\n    value: function splice(start, deleteCount, inserted, removeDirection) {\n      var tailPos = start + deleteCount;\n      var tail = this.extractTail(tailPos);\n      var startChangePos = this.nearestInputPos(start, removeDirection);\n      var changeDetails = new ChangeDetails({\n        tailShift: startChangePos - start // adjust tailShift if start was aligned\n\n      }).aggregate(this.remove(startChangePos)).aggregate(this.append(inserted, {\n        input: true\n      }, tail));\n      return changeDetails;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        _value: this.value\n      };\n    },\n    set: function set(state) {\n      this._value = state._value;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(value) {\n      this.resolve(value);\n    }\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.value;\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {}, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.doParse(this.value);\n    },\n    set: function set(value) {\n      this.value = this.doFormat(value);\n    }\n    /** Value that includes raw user input */\n\n  }, {\n    key: \"rawInputValue\",\n    get: function get() {\n      return this.extractInput(0, this.value.length, {\n        raw: true\n      });\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {\n        raw: true\n      }, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return Masked;\n}();\n\nMasked.DEFAULTS = {\n  format: function format(v) {\n    return v;\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\nIMask.Masked = Masked;\nexport default Masked;","map":{"version":3,"sources":["/home/mani/projects/jobportal/webapp/adminportal/node_modules/imask/esm/masked/base.js"],"names":["a","_createClass","b","_classCallCheck","isString","ChangeDetails","ContinuousTailDetails","IMask","Masked","opts","_value","_update","Object","assign","DEFAULTS","isInitialized","key","value","updateOptions","keys","length","withValueRefresh","bind","reset","resolve","append","input","doCommit","nearestInputPos","cursorPos","direction","extractInput","fromPos","arguments","undefined","toPos","slice","extractTail","appendTail","tail","String","appendTo","_appendCharRaw","ch","flags","doPrepare","inserted","rawInserted","_appendChar","checkTail","consistentState","state","details","consistentTail","appended","doValidate","beforeTailState","overwrite","shiftBefore","tailDetails","toString","_appendPlaceholder","str","Error","_beforeTailState","ci","aggregate","tailShift","remove","fn","_refreshing","rawInput","rawInputValue","ret","indexOf","runIsolated","_isolated","prepare","validate","parent","commit","doFormat","format","doParse","parse","splice","start","deleteCount","removeDirection","tailPos","startChangePos","changeDetails","get","set","raw","v"],"mappings":"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","sourcesContent":["import { a as _createClass, b as _classCallCheck } from '../_rollupPluginBabelHelpers-3c58f0e3.js';\nimport { isString } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport IMask from '../core/holder.js';\n\n/** Supported mask type */\n\n/** Provides common masking stuff */\nvar Masked =\n/*#__PURE__*/\nfunction () {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n  function Masked(opts) {\n    _classCallCheck(this, Masked);\n\n    this._value = '';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, {}, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  _createClass(Masked, [{\n    key: \"updateOptions\",\n    value: function updateOptions(opts) {\n      if (!Object.keys(opts).length) return;\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n    /**\r\n      Sets new options\r\n      @protected\r\n    */\n\n  }, {\n    key: \"_update\",\n    value: function _update(opts) {\n      Object.assign(this, opts);\n    }\n    /** Mask state */\n\n  }, {\n    key: \"reset\",\n\n    /** Resets value */\n    value: function reset() {\n      this._value = '';\n    }\n    /** */\n\n  }, {\n    key: \"resolve\",\n\n    /** Resolve new value */\n    value: function resolve(value) {\n      this.reset();\n      this.append(value, {\n        input: true\n      }, '');\n      this.doCommit();\n      return this.value;\n    }\n    /** */\n\n  }, {\n    key: \"nearestInputPos\",\n\n    /** Finds nearest input position in direction */\n    value: function nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n    /** Extracts value in range considering flags */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return this.value.slice(fromPos, toPos);\n    }\n    /** Extracts tail in range */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n    }\n    /** Appends tail */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n      return tail.appendTo(this);\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      ch = this.doPrepare(ch, flags);\n      if (!ch) return new ChangeDetails();\n      this._value += ch;\n      return new ChangeDetails({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendChar\",\n    value: function _appendChar(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var checkTail = arguments.length > 2 ? arguments[2] : undefined;\n      var consistentState = this.state;\n\n      var details = this._appendCharRaw(ch, flags);\n\n      if (details.inserted) {\n        var consistentTail;\n        var appended = this.doValidate(flags) !== false;\n\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          var beforeTailState = this.state;\n\n          if (this.overwrite) {\n            consistentTail = checkTail.state;\n            checkTail.shiftBefore(this.value.length);\n          }\n\n          var tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString(); // if ok, rollback state after tail\n\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        } // revert all if something went wrong\n\n\n        if (!appended) {\n          details = new ChangeDetails();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n\n      return details;\n    }\n    /** Appends optional placeholder at end */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      return new ChangeDetails();\n    }\n    /** Appends symbols considering flags */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"append\",\n    value: function append(str, flags, tail) {\n      if (!isString(str)) throw new Error('value should be string');\n      var details = new ChangeDetails();\n      var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n      if (flags.tail) flags._beforeTailState = this.state;\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        details.aggregate(this._appendChar(str[ci], flags, checkTail));\n      } // append tail but aggregate only tailShift\n\n\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n\n      return details;\n    }\n    /** */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n      return new ChangeDetails();\n    }\n    /** Calls function and reapplies current value */\n\n  }, {\n    key: \"withValueRefresh\",\n    value: function withValueRefresh(fn) {\n      if (this._refreshing || !this.isInitialized) return fn();\n      this._refreshing = true;\n      var rawInput = this.rawInputValue;\n      var value = this.value;\n      var ret = fn();\n      this.rawInputValue = rawInput; // append lost trailing chars at end\n\n      if (this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.value.length), {}, '');\n      }\n\n      delete this._refreshing;\n      return ret;\n    }\n    /** */\n\n  }, {\n    key: \"runIsolated\",\n    value: function runIsolated(fn) {\n      if (this._isolated || !this.isInitialized) return fn(this);\n      this._isolated = true;\n      var state = this.state;\n      var ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n    /**\r\n      Prepares string before mask processing\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doPrepare\",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.prepare ? this.prepare(str, this, flags) : str;\n    }\n    /**\r\n      Validates if value is acceptable\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doValidate\",\n    value: function doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n    /**\r\n      Does additional processing in the end of editing\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n    /** */\n\n  }, {\n    key: \"doFormat\",\n    value: function doFormat(value) {\n      return this.format ? this.format(value, this) : value;\n    }\n    /** */\n\n  }, {\n    key: \"doParse\",\n    value: function doParse(str) {\n      return this.parse ? this.parse(str, this) : str;\n    }\n    /** */\n\n  }, {\n    key: \"splice\",\n    value: function splice(start, deleteCount, inserted, removeDirection) {\n      var tailPos = start + deleteCount;\n      var tail = this.extractTail(tailPos);\n      var startChangePos = this.nearestInputPos(start, removeDirection);\n      var changeDetails = new ChangeDetails({\n        tailShift: startChangePos - start // adjust tailShift if start was aligned\n\n      }).aggregate(this.remove(startChangePos)).aggregate(this.append(inserted, {\n        input: true\n      }, tail));\n      return changeDetails;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        _value: this.value\n      };\n    },\n    set: function set(state) {\n      this._value = state._value;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(value) {\n      this.resolve(value);\n    }\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.value;\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {}, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.doParse(this.value);\n    },\n    set: function set(value) {\n      this.value = this.doFormat(value);\n    }\n    /** Value that includes raw user input */\n\n  }, {\n    key: \"rawInputValue\",\n    get: function get() {\n      return this.extractInput(0, this.value.length, {\n        raw: true\n      });\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {\n        raw: true\n      }, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return Masked;\n}();\nMasked.DEFAULTS = {\n  format: function format(v) {\n    return v;\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\nIMask.Masked = Masked;\n\nexport default Masked;\n"]},"metadata":{},"sourceType":"module"}